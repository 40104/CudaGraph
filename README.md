# CudaGraph
_________________________________________________________________________________________________________________________________________________________________________________
1)что сделано 1
2)Что сделано 2
3) ....
_________________________________________________________________________________________________________________________________________________________________________________
В рамках выпускной квалицикационной работы необходимо было создать инструмент, позволяющий выполнять алгоритмы над графами наиболее эффективно. Для этого была выбрана связка Сuda + C++, позволяющая обрабатывать алгоритмы наиболее быстро. Для упрощения работы с данными алгоритмами, была произведена интеграция полученного кода посредством языка Cython в виде библиотеки языка Python. Для проверки эффективности полученного решения были сгенерированы графы с колличеством вершин от 200 до 2000 и вериятностью связывания 80% и взят граф вершины которого - названия статей в Википедии, а ребра - это наличие связи между выбранными страницами. Всего граф содержит 4604 вершины. Все работы проводились на ПК с операционной системой - Windows 10, CPU - Intel I5 7300HQ, GPU - Nvidia GTX 1050 4GB, Ram - 8Gb. 

Стоит заметить что данная работа создавалась до появления компилятора NVC++, а текущий компилятор NVCC не мог быть использован языком Cython. Для обхода ограничений была использована библитека TrustRTC, позволяющая как создавать Kernel, так и использовать Cuda Trust функции. В последствии данную библитеку можно пересобрать используя компилятор NVC++, что позволит избежать такого колличества файлов и повысить производительность GPU вычислений.

Для начала был создан файл graph.cpp в котором были созданы все необходимые алгоритмы как в линейной, так и многопоточной вариации. Для анализа использовались алгоритмы Флойда-Уоршелла, Прима, Краскала(С использованием рекурсивной функции быстрой сортировки) и алгоритм Дейкстры. Для объявления функций и интеграции библиотек используется файл graph.h.

Как уже было сказано, на момент написания работы не было возможности использовать единый файл и единый компилятор как для CPU вычислений, так и для GPU вычислений. Поэтому для обучения и сравнения результатов был создан файл kernel.cu, логика которого уже состоит в использовании самостоятельного класса, позволяющего хранить данные графа, и внутренние функции, приминяемые к графу.

Для интеграции полученных в файлах graph.h и graph.cpp функций исполся язык программирования Cython. Файл cpu_graph.pyx содержит Python обвязку вызываемых фукнций, а файл setup_cpu_graph.py методы и флаги компиляции.

Для воссоздания Cuda функций используется библитека TrustRTC. В файле Gpu_graph_trust.py созданы функции реализующие алгоритмы Флойда-Уоршелла и Краскала. От алгоритмов Прима и Дейкстры пришлось отказаться в виду их низкой эффективности. Файл graph_apu.py объединяет внутри класса как библитеку С++ функций, так и TrustRTC функций. Также для сравнения результатов он содержит примеры реализации всех алгоритмов с использованием чистого Python.

# Алгоритм Флойда-Уоршелла

![image](https://user-images.githubusercontent.com/87370709/126149042-66d8a1e9-5922-4996-a0b8-db27f9f18159.png)

# Алгоритм Прима

![image](https://user-images.githubusercontent.com/87370709/126149153-4a8f5caa-88ff-426b-8afd-0c1841b10ffc.png)

# Алгоритм Краскала

![image](https://user-images.githubusercontent.com/87370709/126149263-4b426bcf-d5ce-49b9-ba4e-cc64968a506b.png)


# Алгоритм Дейкстры

![image](https://user-images.githubusercontent.com/87370709/126149330-53ac8645-458e-462c-9ad1-9a71d507f587.png)

# Алгоритм Wiki

![image](https://user-images.githubusercontent.com/87370709/126149417-8770f525-0833-4a4b-af36-56feb985edb7.png)

![image](https://user-images.githubusercontent.com/87370709/126149452-9f5bd5f9-56eb-472f-b882-935648075217.png)

# Итог

В результате работы получилось реализовать многопоточные варианты алгоритмов и ипользовать их для создания библитеку, имеющую более высокую приозводительность. Изначально полученные данные вызвали у меня вопросы, однако перепроверив результат и разобравшись в вопросе был сделан вывод, что Cython при компилировании перекладывает вычисления на специальные векторные интсрукции AVX и SSE, приминяющие векторные блоки в CPU, дающие прирост производительности векторных вычислений. Хотя и полученные результаты уже могут упросить многим программистам вычисления, все же для полноценного использования библитеки имеет место переписать код под использование NVC++ компилятора и объединение всех функций в один файл. Также можно реализовать более удобную интеграцию графов из Python кода. Сейчас это возможно только путем выгрузки графа в TXT файл с последующим его чтением библитекой. 

